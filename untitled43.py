# -*- coding: utf-8 -*-
"""Untitled43.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GobsxIk_LlDQZUaUGNWiBXATI5Xtq_pC
"""

url = 'https://anaconda.org/conda-forge/libta-lib/0.4.0/download/linux-64/libta-lib-0.4.0-h166bdaf_1.tar.bz2'
!curl -L $url | tar xj -C /usr/lib/x86_64-linux-gnu/ lib --strip-components=1
!pip install conda-package-handling
!wget https://anaconda.org/conda-forge/ta-lib/0.5.1/download/linux-64/ta-lib-0.5.1-py311h9ecbd09_0.conda
!cph x ta-lib-0.5.1-py311h9ecbd09_0.conda
!mv ./ta-lib-0.5.1-py311h9ecbd09_0/lib/python3.11/site-packages/talib /usr/local/lib/python3.11/dist-packages/
import talib

import numpy as np
import pandas as pd
import yfinance as yf
import talib
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import datetime
import requests
import json

def fetch_stock_data(ticker, period="2y", interval="1d"):
    df = yf.download(ticker, period=period, interval=interval)
    df = df.reset_index()
    df = df.rename(columns={"Date": "datetime"})
    return df

# Select mode
trading_mode = input("Enter mode (swing/intraday): ").strip().lower()
ticker = "MRF.NS"  # Change ticker if needed

if trading_mode == "intraday":
    stock_data = fetch_stock_data(ticker, period="3mo", interval="15m")
else:
    stock_data = fetch_stock_data(ticker, period="2y", interval="1d")

print(stock_data.tail())

# Fetch stock data (ensure 'stock_data' is defined)
stock_data = fetch_stock_data("MRF.NS")  # Replace with your function for fetching data

# ---------------------- FIX COLUMN FORMAT ----------------------
# Reset MultiIndex if present
if isinstance(stock_data.columns, pd.MultiIndex):
    stock_data.columns = stock_data.columns.get_level_values(1)  # Keep only the second level (actual column names)

# Rename columns for clarity
stock_data.columns = ["Date", "Open", "High", "Low", "Close", "Volume"]

# Convert 'Date' column to datetime format
stock_data["Date"] = pd.to_datetime(stock_data["Date"])

# Set Date as Index for better visualization
stock_data.set_index("Date", inplace=True)

# Display the cleaned DataFrame
print(stock_data.tail())

# Now apply technical indicators
stock_data = add_technical_indicators(stock_data)

import talib
import numpy as np

def add_technical_indicators(df):
    df["SMA_20"] = talib.SMA(df["Close"].astype(float).values.flatten(), timeperiod=20)
    df["EMA_10"] = talib.EMA(df["Close"].astype(float).values.flatten(), timeperiod=10)
    df["RSI_14"] = talib.RSI(df["Close"].astype(float).values.flatten(), timeperiod=14)

    macd, macd_signal, _ = talib.MACD(df["Close"].astype(float).values.flatten())
    df["MACD"] = macd
    df["MACD_Signal"] = macd_signal

    upper_bb, middle_bb, lower_bb = talib.BBANDS(df["Close"].astype(float).values.flatten(), timeperiod=20)
    df["Upper_BB"] = upper_bb
    df["Middle_BB"] = middle_bb
    df["Lower_BB"] = lower_bb

    df["ATR_14"] = talib.ATR(df["High"].astype(float).values.flatten(),
                             df["Low"].astype(float).values.flatten(),
                             df["Close"].astype(float).values.flatten(),
                             timeperiod=14)

    df["ADX"] = talib.ADX(df["High"].astype(float).values.flatten(),
                          df["Low"].astype(float).values.flatten(),
                          df["Close"].astype(float).values.flatten(),
                          timeperiod=14)

    df["CCI"] = talib.CCI(df["High"].astype(float).values.flatten(),
                          df["Low"].astype(float).values.flatten(),
                          df["Close"].astype(float).values.flatten(),
                          timeperiod=14)

    return df

# Ichimoku Cloud
stock_data["Ichimoku_Conv"] = (stock_data["High"].rolling(9).max() + stock_data["Low"].rolling(9).min()) / 2
stock_data["Ichimoku_Base"] = (stock_data["High"].rolling(26).max() + stock_data["Low"].rolling(26).min()) / 2

# SuperTrend
def calculate_supertrend(df, period=10, multiplier=3):
    high = df["High"]
    low = df["Low"]
    close = df["Close"]

    atr = talib.ATR(high, low, close, timeperiod=period)
    hl2 = (high + low) / 2
    upper_band = hl2 + (multiplier * atr)
    lower_band = hl2 - (multiplier * atr)

    supertrend = [0] * len(df)
    trend = True  # True means uptrend, False means downtrend

    for i in range(1, len(df)):
        if close[i] > upper_band[i - 1]:
            trend = True
        elif close[i] < lower_band[i - 1]:
            trend = False

        supertrend[i] = upper_band[i] if trend else lower_band[i]

    df["SuperTrend"] = supertrend

calculate_supertrend(stock_data)

# Ensure stock_data has the correct format
if isinstance(stock_data, pd.DataFrame):
    stock_data = add_technical_indicators(stock_data)
    print(stock_data.tail())
else:
    print("Error: stock_data is not a DataFrame")

def add_pattern_recognition(df):
    df["Engulfing"] = talib.CDLENGULFING(df["Open"], df["High"], df["Low"], df["Close"])
    df["Doji"] = talib.CDLDOJI(df["Open"], df["High"], df["Low"], df["Close"])
    df["Hammer"] = talib.CDLHAMMER(df["Open"], df["High"], df["Low"], df["Close"])
    return df

stock_data = add_pattern_recognition(stock_data)

# Drop NaN values
stock_data.dropna(inplace=True)

# Feature selection
features = ["Close", "SMA_20", "EMA_10", "RSI_14", "MACD", "Upper_BB", "Lower_BB",
            "ATR_14", "Ichimoku_Conv", "Ichimoku_Base", "ADX", "CCI", "SuperTrend",
            "Engulfing", "Doji", "Hammer"]
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(stock_data[features])

# Create sequences for LSTM
def create_sequences(data, lookback=30):
    X, Y = [], []
    for i in range(len(data) - lookback):
        X.append(data[i:i+lookback])
        Y.append(data[i+lookback, 0])  # Predict 'Close' price
    return np.array(X), np.array(Y)

lookback = 30
X, Y = create_sequences(scaled_data, lookback)

# Split into train-test sets
split = int(len(X) * 0.8)
X_train, Y_train = X[:split], Y[:split]
X_test, Y_test = X[split:], Y[split:]

model = Sequential([
    LSTM(100, return_sequences=True, input_shape=(lookback, X.shape[2])),
    Dropout(0.2),
    LSTM(100, return_sequences=True),
    Dropout(0.2),
    LSTM(100),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer="adam", loss="mse")
model.fit(X_train, Y_train, epochs=50, batch_size=32, validation_data=(X_test, Y_test))

predictions = model.predict(X_test)
predictions = scaler.inverse_transform(np.hstack((predictions, np.zeros((predictions.shape[0], len(features)-1)))))[:, 0]

# Convert Y_test back to original scale
actual_prices = scaler.inverse_transform(np.hstack((Y_test.reshape(-1, 1), np.zeros((Y_test.shape[0], len(features)-1)))))[:, 0]

plt.figure(figsize=(14, 7))
plt.plot(stock_data.index[-len(actual_prices):], actual_prices, label="Actual Price", color="blue")
plt.plot(stock_data.index[-len(predictions):], predictions, label="Predicted Price", color="red")
plt.xlabel("Date")
plt.ylabel("Stock Price")
plt.legend()
plt.title(f"{ticker} Stock Price Prediction")
plt.show()

import pandas as pd
import yfinance as yf
import numpy as np

def fetch_live_price(symbol):
    """Fetch the most recent stock closing price using yfinance."""
    stock = yf.Ticker(symbol)
    live_data = stock.history(period="1d")  # Get the latest available daily price
    return live_data["Close"].iloc[-1] if not live_data.empty else None

# Get live price
live_price = fetch_live_price("MRF.NS")
print(f"Live Price of MRF.NS: {live_price}")

# Update stock_data with the latest price (if available)
if live_price:
    latest_row = stock_data.iloc[-1].copy()
    latest_row["Close"] = live_price

    # Convert latest_row to DataFrame & use pd.concat()
    stock_data = pd.concat([stock_data, pd.DataFrame([latest_row])], ignore_index=True)

# Prepare live data input for prediction
latest_data = stock_data[features].iloc[-lookback:].values
latest_scaled = scaler.transform(latest_data).reshape(1, lookback, len(features))

# Predict next price
predicted_next_price = model.predict(latest_scaled)
predicted_next_price = scaler.inverse_transform(
    np.hstack((predicted_next_price, np.zeros((1, latest_scaled.shape[2] - 1))))
)[:, 0][0]

print(f"Predicted Next Price: {predicted_next_price}")